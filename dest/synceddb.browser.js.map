{
  "version": 3,
  "sources": ["../SyncedDB.ts"],
  "sourcesContent": ["import * as idbx from \"idbx\";\nimport { SyncedDBOptions } from \"./SyncedDBOptions.ts\";\nimport { SyncedDBAction } from \"./SyncedDBAction.ts\";\nimport { SyncedDBState } from \"./SyncedDBState.ts\";\n\nexport class SyncedDB<T> {\n  static createStore(db: IDBDatabase, storeName: string, keyPath = \"id\") {\n    const store = db.createObjectStore(storeName, {\n      keyPath,\n      autoIncrement: false,\n    });\n    store.createIndex(\"syncState\", \"sync_state\", { unique: false });\n    store.createIndex(\"syncAction\", \"sync_action\", { unique: false });\n    return store;\n  }\n\n  options: SyncedDBOptions;\n\n  syncState = Promise.resolve(\"unsynced\");\n  lastSync = 0;\n\n  constructor(\n    public db: IDBDatabase,\n    public storeName: string,\n    options?: Partial<SyncedDBOptions>,\n  ) {\n    this.options = {\n      keyName: \"id\",\n      url: (globalThis as any).location?.origin ?? \"\",\n      autoSync: false,\n      createPath: \"/api/create\",\n      readPath: \"/api/read\",\n      updatePath: \"/api/update\",\n      deletePath: \"/api/delete\",\n      readAllPath: \"/api/read_all\",\n      syncPath: \"/api/sync\",\n      ...options,\n    };\n    globalThis.addEventListener(\"online\", () => {\n      this.syncState = new Promise((resolve) => {\n        this.sync()\n          .then(() => resolve(\"synced\"))\n          .catch(console.error);\n      });\n    });\n    globalThis.addEventListener(\"offline\", () => {\n      this.syncState = Promise.resolve(\"unsynced\");\n    });\n  }\n\n  // create a method that writes into the indexeddb store and send a fetch\n  // request to the server to update the database on the server\n  async create(data: T) {\n    const store = this.#getStore(\"readwrite\");\n    const item = this.#addSyncState(data, \"create\", \"unsynced\");\n    const key = \"TMP-\" + crypto.randomUUID();\n    item[this.options.keyName] = key;\n    await idbx.add(store, item);\n\n    if (navigator.onLine) {\n      return this.#fetchOne(\"POST\", this.options.createPath, data, key);\n    }\n\n    return item as T;\n  }\n\n  // create a method that reads from the indexeddb store and send a fetch\n  // request to the server to update the database on the server\n  async read(key: string, forceSync = false) {\n    const store = this.#getStore(\"readonly\");\n    const result = await idbx.get<T>(store, key);\n\n    if (!result) {\n      // sync if result is not found\n      forceSync = true;\n    }\n\n    if (navigator.onLine && !key.startsWith(\"TMP-\") && forceSync) {\n      return this.#fetchOne(\"GET\", this.options.readPath, undefined, key);\n    }\n\n    return result as T;\n  }\n\n  // create a method that updates the indexeddb store and send a fetch\n  // request to the server to update the database on the server\n  async update(data: T) {\n    if (!data[this.options.keyName]) {\n      throw new Error(\"Missing key\");\n    }\n    const key = data[this.options.keyName] as string;\n\n    const store = this.#getStore(\"readwrite\");\n    const item = this.#addSyncState(data, \"update\", \"unsynced\");\n    await idbx.put(store, item);\n\n    if (navigator.onLine) {\n      return this.#fetchOne(\"PUT\", this.options.updatePath, data, key);\n    }\n\n    return item as T;\n  }\n\n  // create a method that deletes from the indexeddb store and send a fetch\n  // request to the server to update the database on the server\n  async delete(key: string) {\n    // check if the record is already registered on the server.\n    // If it isn't, then we can delete it from the store right now.\n    if (key.startsWith(\"TMP-\")) {\n      // delete the record\n      const store = this.#getStore(\"readwrite\");\n      await idbx.del(store, key);\n      return;\n    }\n\n    const read = this.#getStore(\"readonly\");\n    const record = await idbx.get<T>(read, key);\n\n    const store = this.#getStore(\"readwrite\");\n    const item = this.#addSyncState(record as T, \"delete\", \"unsynced\");\n    await idbx.put(store, item);\n\n    // delete the record\n    if (navigator.onLine) {\n      await this.#fetchOne(\"DELETE\", this.options.deletePath, undefined, key);\n    }\n  }\n\n  // create a method that reads all from the indexeddb store and send a fetch\n  // request to the server to update the database on the server\n  async readAll(forceSync = false) {\n    const tx = this.db.transaction(this.storeName, \"readonly\");\n    const store = tx.objectStore(this.storeName);\n    const result = await idbx.getAll(store);\n\n    if (navigator.onLine && (result.length === 0 || forceSync)) {\n      const url = new URL(this.options.url + this.options.readAllPath);\n      const response = await fetch(url, {\n        method: \"GET\",\n        mode: \"cors\",\n        credentials: \"include\",\n      });\n      if (response.ok) {\n        const json = await response.json() ?? [];\n        const store = this.#getStore(\"readwrite\");\n        const items = (json ?? []).map((item: any) =>\n          this.#addSyncState(item, \"none\", \"synced\")\n        );\n\n        await idbx.putBulk(store, items);\n\n        // add the TMP- items to the items array\n        const tmpItems = result.filter((item: any) =>\n          item[this.options.keyName].startsWith(\"TMP-\")\n        );\n        return [...items, ...tmpItems] as T[];\n      } else {\n        // handle error\n        console.log(\"fetch entries failed\", response);\n      }\n    }\n\n    return result as T[];\n  }\n\n  async sync(timestamp: number | null = null) {\n    const offline = !navigator.onLine;\n    if (offline) {\n      return;\n    }\n\n    if (timestamp === null) {\n      timestamp = this.lastSync;\n    }\n\n    const tx = this.db.transaction(this.storeName, \"readonly\");\n    const store = tx.objectStore(this.storeName);\n    const index = store.index(\"syncState\");\n    const syncStore = index.objectStore;\n\n    const result = await idbx.getAll(syncStore);\n    const unsynced = result.filter((item: any) =>\n      item.sync_state === \"unsynced\"\n    );\n\n    if (unsynced.length === 0) {\n      return;\n    }\n\n    // filter all items where keyName starts with TMP-\n    const key = this.options.keyName;\n    const createTmpIds = unsynced\n      .filter((item: any) => item.sync_action === \"create\")\n      .map((item: any) => item[key]);\n\n    // create groups from sync_action\n    const groups = unsynced.reduce((acc: any, item: any) => {\n      const { sync_action } = item;\n      if (!acc[sync_action]) {\n        acc[sync_action] = [];\n      }\n      acc[sync_action].push(item);\n      return acc;\n    }, {});\n\n    const url = new URL(this.options.url + this.options.syncPath);\n    url.searchParams.set(\"t\", timestamp.toString());\n\n    const response = await fetch(url, {\n      method: \"POST\",\n      headers: { \"Content-Type\": \"application/json\" },\n      body: JSON.stringify(groups),\n      mode: \"cors\",\n      credentials: \"include\",\n    });\n\n    if (response.ok) {\n      const json = await response.json();\n      const store = this.#getStore(\"readwrite\");\n      const items = json.changed.map((item: any) =>\n        this.#addSyncState(item, \"none\", \"synced\")\n      );\n\n      await Promise.all([\n        // delete all items that are flagged as created on the client\n        idbx.delBulk(store, createTmpIds),\n        // delete all items that are flagged as deleted from the server\n        idbx.delBulk(store, json.deleted),\n        // update all items where sync_state is unsynced\n        idbx.putBulk(store, items),\n      ]);\n\n      this.lastSync = new Date(json.timestamp).getTime();\n    } else {\n      // handle error\n      console.log(\"sync failed\", response);\n    }\n  }\n\n  #addSyncState(\n    data: T | undefined,\n    sync_action: SyncedDBAction,\n    sync_state: SyncedDBState,\n  ) {\n    return { ...data, sync_action, sync_state } as T;\n  }\n\n  #getStore(mode: IDBTransactionMode) {\n    const tx = this.db.transaction(this.storeName, mode);\n    return tx.objectStore(this.storeName);\n  }\n\n  #buildUrl(path: string, key: string) {\n    const url = new URL(this.options.url + path);\n    if (!key.startsWith(\"TMP-\")) {\n      url.searchParams.set(this.options.keyName as string, key);\n    }\n    return url;\n  }\n\n  #fetchOne = async (\n    method: string,\n    path: string,\n    data: T | undefined,\n    key: string,\n  ) => {\n    const canHaveBody = method !== \"GET\" && method !== \"DELETE\";\n    const body = !canHaveBody ? undefined : JSON.stringify(data);\n    const url = this.#buildUrl(path, key);\n    const response = await fetch(url, {\n      method,\n      body,\n      mode: \"cors\",\n      credentials: \"include\",\n    });\n\n    console.log(response.ok, response.status);\n\n    if (response.ok) {\n      const store = this.#getStore(\"readwrite\");\n      if (method === \"DELETE\") {\n        await idbx.del(store, key);\n        return;\n      } else {\n        const json = await response.json();\n        const item = this.#addSyncState(json, \"none\", \"synced\");\n        await idbx.put(store, item);\n        return item as T;\n      }\n    } else if (response.status === 404) {\n      const store = this.#getStore(\"readwrite\");\n      await idbx.del(store, key);\n    } else {\n      // handle error\n      console.log(\"read/write/delete entry failed\", response);\n    }\n  };\n}\n"],
  "mappings": "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",
  "names": ["idbx", "SyncedDB", "db", "storeName", "options", "resolve", "keyPath", "store", "data", "#getStore", "item", "#addSyncState", "key", "#fetchOne", "forceSync", "result", "read", "record", "url", "response", "json", "items", "tmpItems", "timestamp", "syncStore", "unsynced", "createTmpIds", "groups", "acc", "sync_action", "sync_state", "mode", "#buildUrl", "path", "method", "body"]
}
