import*as n from"npm:idbx";import b from"npm:idbatch";var v=0,S=0;function E(T=1){let m=Date.now();return m===v?S++:(v=m,S=0),`${m}${S.toString().padStart(T,"0")}`}var w=class extends EventTarget{constructor(e,i,s){super();this.db=e;this.storeName=i;this.options={keyName:"id",url:location?.origin??"",autoSync:!1,createPath:"/api/create",readPath:"/api/read",updatePath:"/api/update",deletePath:"/api/delete",readAllPath:"/api/read_all",syncPath:"/api/sync",testRun:!1,...s},globalThis.addEventListener("online",()=>{this.syncState=new Promise(t=>{this.sync().then(()=>t("synced")).catch(console.error)})}),globalThis.addEventListener("offline",()=>{this.syncState=Promise.resolve("unsynced")})}static createStore(e,i,s){let t=e.createObjectStore(i,{keyPath:"id",autoIncrement:!1,...s});return t.createIndex("primaryKey","id",{unique:!0}),t.createIndex("syncState","sync_state",{unique:!1}),t.createIndex("syncAction","sync_action",{unique:!1}),t}options;syncState=Promise.resolve("unsynced");lastSync=0;async create(e){let i=n.getStore(this.db,this.storeName,"readwrite"),s=this.#e(e,"create","unsynced"),t;if(i.autoIncrement?(t=await n.add(i,s),e[this.options.keyName]=t):(t="TMP-"+crypto.randomUUID(),e[this.options.keyName]=s[this.options.keyName]=t,await n.add(i,s)),navigator.onLine){let c=this.options.createPath,d=await this.#t("POST",c,e,t);return this.dispatchEvent(new MessageEvent("created",{data:d})),d}return s}async read(e,i=!1){let s=n.getStore(this.db,this.storeName),t=await n.get(s,e);if(t||(i=!0),navigator.onLine&&t?.sync_action==="create"||navigator.onLine&&i){let c=this.options.readPath,d=await this.#t("GET",c,void 0,e);return this.dispatchEvent(new MessageEvent("read",{data:d})),d}return this.dispatchEvent(new MessageEvent("read",{data:t})),t}async update(e){if(!e[this.options.keyName])throw new Error("Missing key");let i=e[this.options.keyName],s=n.getStore(this.db,this.storeName,"readwrite"),t=this.#e(e,"update","unsynced");if(await n.put(s,t),navigator.onLine){let c=this.options.updatePath,d=await this.#t("PUT",c,e,i);return this.dispatchEvent(new MessageEvent("updated",{data:d})),d}return t}async delete(e){let i=n.getStore(this.db,this.storeName),s=await n.get(i,e);if(s?.sync_action==="create"){let d=n.getStore(this.db,this.storeName,"readwrite");await n.del(d,e);return}let t=n.getStore(this.db,this.storeName,"readwrite"),c=this.#e(s,"delete","unsynced");if(await n.put(t,c),navigator.onLine){let d=this.options.deletePath;await this.#t("DELETE",d,void 0,e),this.dispatchEvent(new MessageEvent("deleted",{data:e}))}}async readAll(e=!1){let i=n.getStore(this.db,this.storeName),s=await n.getAll(i);if(navigator.onLine&&(s.length===0||e)){let t=new URL(this.options.url+this.options.readAllPath),c;if(this.options.testRun?(console.log(`TEST RUN: GET ${t}`),c=new Response(JSON.stringify(s),{status:200,headers:{"Content-Type":"application/json"}})):c=await fetch(t,{method:"GET",mode:"cors",credentials:"include"}),c.ok){let h=(await c.json()??[]??[]).map(r=>this.#e(r,"none","synced")),l=s.filter(r=>!h.some(p=>p[this.options.keyName]===r[this.options.keyName])).map(r=>r[this.options.keyName]),f=h.filter(r=>s.some(p=>p[this.options.keyName]===r[this.options.keyName]));await b(this.db,[{method:"del",keys:l,storeName:this.storeName},{method:"put",data:f,storeName:this.storeName}],"readwrite").completed;let o=n.getStore(this.db,this.storeName);return s=await n.getAll(o),this.dispatchEvent(new MessageEvent("readAll",{data:s})),s}else console.log("fetch entries failed",c)}return this.dispatchEvent(new MessageEvent("readAll",{data:s})),s}async sync(e=null){if(!navigator.onLine)return;e===null&&(e=this.lastSync);let c=n.getStore(this.db,this.storeName).index("syncState").objectStore,h=(await n.getAll(c)).filter(a=>a.sync_state==="unsynced");if(h.length===0)return;let l=this.options.keyName,f=h.filter(a=>a.sync_action==="create").map(a=>a[l]),o=h.reduce((a,u)=>{if("sync_action"in u){let{sync_action:y}=u;y!==void 0&&(a[y]||(a[y]=[]),a[y].push(u))}return a},{}),r=new URL(this.options.url+this.options.syncPath);r.searchParams.set("t",e.toString());let p;if(this.options.testRun){let a=[];"delete"in o&&(a=o.delete.map(g=>g[l]));let u=[];"update"in o&&(u=JSON.parse(JSON.stringify(o.update)));let y=[];"create"in o&&(y=JSON.parse(JSON.stringify(o.create)).map(g=>(g[l]=E(3),g))),console.log(`TEST RUN: POST ${r}`),p=new Response(JSON.stringify({deleted:a,changed:[...u,...y],timestamp:Date.now()}),{status:200,headers:{"Content-Type":"application/json"}})}else p=await fetch(r,{method:"POST",headers:{"Content-Type":"application/json"},body:JSON.stringify(o),mode:"cors",credentials:"include"});if(p.ok){let a=await p.json(),u=this.#e(a.changed,"none","synced");await b(this.db,[{method:"del",storeName:this.storeName,keys:f},{method:"del",storeName:this.storeName,keys:a.deleted},{method:"put",storeName:this.storeName,data:u}],"readwrite").completed,this.dispatchEvent(new MessageEvent("synced",{data:a})),this.lastSync=new Date(a.timestamp).getTime()}else console.log("sync failed",p)}#e(e,i,s){return Array.isArray(e)?e.map(t=>({...t,sync_action:i,sync_state:s})):{...e,sync_action:i,sync_state:s}}#s(e,i){let s=new URL(this.options.url+e);return i&&s.searchParams.set(this.options.keyName,i.toString()),s}#t=async(e,i,s,t)=>{let d=e!=="GET"&&e!=="DELETE"?JSON.stringify(s):void 0,h=this.#s(i,t),l,f=!this.options.testRun;if(this.options.testRun){let o=d?JSON.parse(d):null,r=200;f=o!==null;let p=new Headers({"Content-Type":"application/json"});if(e==="POST"){let a=t??E(3);o!==null&&this.options.keyName in o&&(o[this.options.keyName]=a),r=201}else e==="DELETE"?(r=204,p.delete("Content-Type")):e==="PUT"&&(r=200);o!==null&&(o=JSON.stringify(o)),console.log(`TEST RUN: ${e} ${h}`),l=new Response(o,{status:r,headers:p})}else l=await fetch(h.toString(),{method:e,body:d,mode:"cors",credentials:"include"});if(l.ok&&l.status>=200&&l.status<300){if(e==="DELETE"&&t){let o=n.getStore(this.db,this.storeName,"readwrite");await n.del(o,t);return}else if(f){let o=await l.json(),r=this.#e(o,"none","synced"),p=n.getStore(this.db,this.storeName,"readwrite");return await n.put(p,r),r}}else if(l.status===404){if(t){let o=n.getStore(this.db,this.storeName,"readwrite");await n.del(o,t)}}else console.log("read/write/delete entry failed",l)}};export{w as SyncedDB};
//# sourceMappingURL=synceddb.js.map
