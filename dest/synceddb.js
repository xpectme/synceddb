import*as n from"npm:idbx";import b from"npm:idbatch";var v=0,S=0;function E(T=1){let m=Date.now();return m===v?S++:(v=m,S=0),`${m}${S.toString().padStart(T,"0")}`}var w=class extends EventTarget{constructor(e,i,s){super();this.db=e;this.storeName=i;this.options={keyName:"id",url:location?.origin??"",autoSync:!1,createPath:"/api/create",readPath:"/api/read",updatePath:"/api/update",deletePath:"/api/delete",readAllPath:"/api/read_all",syncPath:"/api/sync",testRun:!1,...s},globalThis.addEventListener("online",()=>{this.syncState=new Promise(t=>{this.sync().then(()=>t("synced")).catch(console.error)})}),globalThis.addEventListener("offline",()=>{this.syncState=Promise.resolve("unsynced")})}static createStore(e,i,s){let t=e.createObjectStore(i,{keyPath:"id",autoIncrement:!1,...s});return t.createIndex("primaryKey","id",{unique:!0}),t.createIndex("syncState","sync_state",{unique:!1}),t.createIndex("syncAction","sync_action",{unique:!1}),t}options;syncState=Promise.resolve("unsynced");lastSync=0;async create(e){let i=n.getStore(this.db,this.storeName,"readwrite"),s=this.#e(e,"create","unsynced"),t;if(i.autoIncrement?(t=await n.add(i,s),e[this.options.keyName]=t):(t="TMP-"+crypto.randomUUID(),e[this.options.keyName]=s[this.options.keyName]=t,await n.add(i,s)),navigator.onLine){let c=this.options.createPath,o=await this.#t("POST",c,e,t);return this.dispatchEvent(new MessageEvent("created",{data:o})),o}return s}async read(e,i=!1){let s=n.getStore(this.db,this.storeName),t=await n.get(s,e);if(t||(i=!0),navigator.onLine&&t?.sync_action==="create"||navigator.onLine&&i){let c=this.options.readPath,o=await this.#t("GET",c,void 0,e);return this.dispatchEvent(new MessageEvent("read",{data:o})),o}return this.dispatchEvent(new MessageEvent("read",{data:t})),t}async update(e){if(!e[this.options.keyName])throw new Error("Missing key");let i=e[this.options.keyName],s=n.getStore(this.db,this.storeName,"readwrite"),t=this.#e(e,"update","unsynced");if(await n.put(s,t),navigator.onLine){let c=this.options.updatePath,o=await this.#t("PUT",c,e,i);return this.dispatchEvent(new MessageEvent("updated",{data:o})),o}return t}async delete(e){let i=n.getStore(this.db,this.storeName),s=await n.get(i,e);if(s?.sync_action==="create"){let o=n.getStore(this.db,this.storeName,"readwrite");await n.del(o,e);return}let t=n.getStore(this.db,this.storeName,"readwrite"),c=this.#e(s,"delete","unsynced");if(await n.put(t,c),navigator.onLine){let o=this.options.deletePath;await this.#t("DELETE",o,void 0,e),this.dispatchEvent(new MessageEvent("deleted",{data:e}))}}async readAll(e=!1){let i=n.getStore(this.db,this.storeName),s=await n.getAll(i);if(navigator.onLine&&(s.length===0||e)){let t=new URL(this.options.url+this.options.readAllPath),c;if(this.options.testRun?(console.log(`TEST RUN: GET ${t}`),c=new Response(JSON.stringify(s),{status:200,headers:{"Content-Type":"application/json"}})):c=await fetch(t,{method:"GET",mode:"cors",credentials:"include"}),c.ok){let u=(await c.json()??[]??[]).map(l=>this.#e(l,"none","synced")),p=s.filter(l=>!u.some(h=>h[this.options.keyName]===l[this.options.keyName])).map(l=>l[this.options.keyName]),r=u.filter(l=>s.some(h=>h[this.options.keyName]===l[this.options.keyName]));await b(this.db,[{method:"del",keys:p,storeName:this.storeName},{method:"put",data:r,storeName:this.storeName}],"readwrite").completed;let d=n.getStore(this.db,this.storeName);return s=await n.getAll(d),this.dispatchEvent(new MessageEvent("readAll",{data:s})),s}else console.log("fetch entries failed",c)}return this.dispatchEvent(new MessageEvent("readAll",{data:s})),s}async sync(e=null){if(!navigator.onLine)return;e===null&&(e=this.lastSync);let c=n.getStore(this.db,this.storeName).index("syncState").objectStore,u=(await n.getAll(c)).filter(a=>a.sync_state==="unsynced");if(u.length===0)return;let p=this.options.keyName,r=u.filter(a=>a.sync_action==="create").map(a=>a[p]),d=u.reduce((a,y)=>{if("sync_action"in y){let{sync_action:f}=y;f!==void 0&&(a[f]||(a[f]=[]),a[f].push(y))}return a},{}),l=new URL(this.options.url+this.options.syncPath);l.searchParams.set("t",e.toString());let h;if(this.options.testRun){let a=[];"delete"in d&&(a=d.delete.map(g=>g[p]));let y=[];"update"in d&&(y=JSON.parse(JSON.stringify(d.update)));let f=[];"create"in d&&(f=JSON.parse(JSON.stringify(d.create)).map(g=>(g[p]=E(3),g))),console.log(`TEST RUN: POST ${l}`),h=new Response(JSON.stringify({deleted:a,changed:[...y,...f],timestamp:Date.now()}),{status:200,headers:{"Content-Type":"application/json"}})}else h=await fetch(l,{method:"POST",headers:{"Content-Type":"application/json"},body:JSON.stringify(d),mode:"cors",credentials:"include"});if(h.ok){let a=await h.json(),y=this.#e(a.changed,"none","synced");await b(this.db,[{method:"del",storeName:this.storeName,keys:r},{method:"del",storeName:this.storeName,keys:a.deleted},{method:"put",storeName:this.storeName,data:y}],"readwrite").completed,this.dispatchEvent(new MessageEvent("synced",{data:a})),this.lastSync=new Date(a.timestamp).getTime()}else console.log("sync failed",h)}#e(e,i,s){return Array.isArray(e)?e.map(t=>({...t,sync_action:i,sync_state:s})):{...e,sync_action:i,sync_state:s}}#s(e,i){let s=new URL(this.options.url+e);return i&&s.searchParams.set(this.options.keyName,i.toString()),s}#t=async(e,i,s,t)=>{let o=e!=="GET"&&e!=="DELETE"?JSON.stringify(s):void 0,u=this.#s(i,t),p;if(this.options.testRun){let r=o?JSON.parse(o):null,d=200,l=new Headers({"Content-Type":"application/json"});if(e==="POST"){let h=t??E(3);r!==null&&this.options.keyName in r&&(r[this.options.keyName]=h),d=201}else e==="DELETE"?(d=204,l.delete("Content-Type")):e==="PUT"&&(d=200);r!==null&&(r=JSON.stringify(r)),console.log(`TEST RUN: ${e} ${u}`),p=new Response(r,{status:d,headers:l})}else p=await fetch(u.toString(),{method:e,body:o,mode:"cors",credentials:"include"});if(p.ok&&p.status>=200&&p.status<300)if(e==="DELETE"&&t){let r=n.getStore(this.db,this.storeName,"readwrite");await n.del(r,t);return}else{let r=await p.json(),d=this.#e(r,"none","synced"),l=n.getStore(this.db,this.storeName,"readwrite");return await n.put(l,d),d}else if(p.status===404){if(t){let r=n.getStore(this.db,this.storeName,"readwrite");await n.del(r,t)}}else console.log("read/write/delete entry failed",p)}};export{w as SyncedDB};
//# sourceMappingURL=synceddb.js.map
