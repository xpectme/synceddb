import*as o from"npm:idbx";var E=0,T=0;function w(v=1){let g=Date.now();return g===E?T++:(E=g,T=0),`${g}${T.toString().padStart(v,"0")}`}var x=class extends EventTarget{constructor(e,i,n){super();this.db=e;this.storeName=i;this.options={keyName:"id",url:location?.origin??"",autoSync:!1,createPath:"/api/create",readPath:"/api/read",updatePath:"/api/update",deletePath:"/api/delete",readAllPath:"/api/read_all",syncPath:"/api/sync",dryRun:!1,...n},globalThis.addEventListener("online",()=>{this.syncState=new Promise(t=>{this.sync().then(()=>t("synced")).catch(console.error)})}),globalThis.addEventListener("offline",()=>{this.syncState=Promise.resolve("unsynced")})}static createStore(e,i,n){let t=e.createObjectStore(i,n??{keyPath:"id",autoIncrement:!1});return t.createIndex("syncState","sync_state",{unique:!1}),t.createIndex("syncAction","sync_action",{unique:!1}),t}options;syncState=Promise.resolve("unsynced");lastSync=0;async create(e){let i=this.#e("readwrite"),n=this.#t(e,"create","unsynced"),t;if(i.autoIncrement||(t="TMP-"+crypto.randomUUID(),n[this.options.keyName]=t),await o.add(i,n),navigator.onLine){let d=this.options.createPath,s=await this.#n("POST",d,e,t);return this.dispatchEvent(new MessageEvent("created",{data:s})),s}return n}async read(e,i=!1){let n=this.#e("readonly"),t=await o.get(n,e);if(t||(i=!0),navigator.onLine&&t?.sync_action==="create"||navigator.onLine&&i){let d=this.options.readPath,s=await this.#n("GET",d,void 0,e);return this.dispatchEvent(new MessageEvent("read",{data:s})),s}return this.dispatchEvent(new MessageEvent("read",{data:t})),t}async update(e){if(!e[this.options.keyName])throw new Error("Missing key");let i=e[this.options.keyName],n=this.#e("readwrite"),t=this.#t(e,"update","unsynced");if(await o.put(n,t),navigator.onLine){let d=this.options.updatePath,s=await this.#n("PUT",d,e,i);return this.dispatchEvent(new MessageEvent("updated",{data:s})),s}return t}async delete(e){let i=this.#e("readonly"),n=await o.get(i,e);if(n?.sync_action==="create"){let s=this.#e("readwrite");await o.del(s,e);return}let t=this.#e("readwrite"),d=this.#t(n,"delete","unsynced");if(await o.put(t,d),navigator.onLine){let s=this.options.deletePath;await this.#n("DELETE",s,void 0,e),this.dispatchEvent(new MessageEvent("deleted",{data:e}))}}async readAll(e=!1){let n=this.db.transaction(this.storeName,"readonly").objectStore(this.storeName),t=await o.getAll(n);if(navigator.onLine&&(t.length===0||e)){let d=new URL(this.options.url+this.options.readAllPath),s;if(this.options.dryRun?(console.log(`DRY RUN: GET ${d}`),s=new Response(JSON.stringify(t),{status:200,headers:{"Content-Type":"application/json"}})):s=await fetch(d,{method:"GET",mode:"cors",credentials:"include"}),s.ok){let f=await s.json()??[],l=this.#e("readwrite"),c=(f??[]).map(r=>this.#t(r,"none","synced"));await o.putBulk(l,c);let p=t.filter(r=>r.sync_action==="create");t=[...c,...p]}else console.log("fetch entries failed",s)}return this.dispatchEvent(new MessageEvent("readAll",{data:t})),t}async sync(e=null){if(!navigator.onLine)return;e===null&&(e=this.lastSync);let s=this.db.transaction(this.storeName,"readonly").objectStore(this.storeName).index("syncState").objectStore,l=(await o.getAll(s)).filter(a=>a.sync_state==="unsynced");if(l.length===0)return;let c=this.options.keyName,p=l.filter(a=>a.sync_action==="create").map(a=>a[c]),r=l.reduce((a,u)=>{if("sync_action"in u){let{sync_action:y}=u;y!==void 0&&(a[y]||(a[y]=[]),a[y].push(u))}return a},{}),S=new URL(this.options.url+this.options.syncPath);S.searchParams.set("t",e.toString());let m;if(this.options.dryRun){let a=[];"delete"in r&&(a=r.delete.map(h=>h[c]));let u=[];"update"in r&&(u=JSON.parse(JSON.stringify(r.update)));let y=[];"create"in r&&(y=JSON.parse(JSON.stringify(r.create)).map(h=>(h[c]=w(3),h))),console.log(`DRY RUN: POST ${S}`),m=new Response(JSON.stringify({deleted:a,changed:[...u,...y],timestamp:Date.now()}),{status:200,headers:{"Content-Type":"application/json"}})}else m=await fetch(S,{method:"POST",headers:{"Content-Type":"application/json"},body:JSON.stringify(r),mode:"cors",credentials:"include"});if(m.ok){let a=await m.json(),u=this.#e("readwrite"),y=a.changed.map(h=>this.#t(h,"none","synced"));await Promise.all([o.delBulk(u,p),o.delBulk(u,a.deleted),o.putBulk(u,y)]),this.dispatchEvent(new MessageEvent("synced",{data:a})),this.lastSync=new Date(a.timestamp).getTime()}else console.log("sync failed",m)}#t(e,i,n){return{...e,sync_action:i,sync_state:n}}#e(e){return this.db.transaction(this.storeName,e).objectStore(this.storeName)}#s(e,i=null){let n=new URL(this.options.url+e);return i&&n.searchParams.set(this.options.keyName,i),n}#n=async(e,i,n,t=null)=>{let s=e!=="GET"&&e!=="DELETE"?JSON.stringify(n):void 0,f=this.#s(i,t),l;if(this.options.dryRun){let c=JSON.parse(s),p=200;if(e==="POST"){let r=w(3);c[this.options.keyName]=r,p=201}else e==="DELETE"?p=204:e==="PUT"&&(p=200);console.log(`DRY RUN: ${e} ${f}`),l=new Response(JSON.stringify(c),{status:p,headers:{"Content-Type":"application/json"}})}else l=await fetch(f,{method:e,body:s,mode:"cors",credentials:"include"});if(l.ok){let c=this.#e("readwrite");if(e==="DELETE"&&t){await o.del(c,t);return}else{let p=await l.json(),r=this.#t(p,"none","synced");return await o.put(c,r),r}}else if(l.status===404){if(t){let c=this.#e("readwrite");await o.del(c,t)}}else console.log("read/write/delete entry failed",l)}};export{x as SyncedDB};
//# sourceMappingURL=synceddb.js.map
