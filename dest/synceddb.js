import*as i from"npm:idbx";var E=0,S=0;function w(v=1){let T=Date.now();return T===E?S++:(E=T,S=0),`${T}${S.toString().padStart(v,"0")}`}var x=class extends EventTarget{constructor(e,o,n){super();this.db=e;this.storeName=o;this.options={keyName:"id",url:location?.origin??"",autoSync:!1,createPath:"/api/create",readPath:"/api/read",updatePath:"/api/update",deletePath:"/api/delete",readAllPath:"/api/read_all",syncPath:"/api/sync",dryRun:!1,...n},globalThis.addEventListener("online",()=>{this.syncState=new Promise(t=>{this.sync().then(()=>t("synced")).catch(console.error)})}),globalThis.addEventListener("offline",()=>{this.syncState=Promise.resolve("unsynced")})}static createStore(e,o,n="id"){let t=e.createObjectStore(o,{keyPath:n,autoIncrement:!1});return t.createIndex("syncState","sync_state",{unique:!1}),t.createIndex("syncAction","sync_action",{unique:!1}),t}options;syncState=Promise.resolve("unsynced");lastSync=0;async create(e){let o=this.#e("readwrite"),n=this.#t(e,"create","unsynced"),t="TMP-"+crypto.randomUUID();if(n[this.options.keyName]=t,await i.add(o,n),navigator.onLine){let d=this.options.createPath,s=await this.#n("POST",d,e,t);return this.dispatchEvent(new MessageEvent("created",{data:s})),s}return n}async read(e,o=!1){let n=this.#e("readonly"),t=await i.get(n,e);if(t||(o=!0),navigator.onLine&&!e.startsWith("TMP-")&&o){let d=this.options.readPath,s=await this.#n("GET",d,void 0,e);return this.dispatchEvent(new MessageEvent("read",{data:s})),s}return this.dispatchEvent(new MessageEvent("read",{data:t})),t}async update(e){if(!e[this.options.keyName])throw new Error("Missing key");let o=e[this.options.keyName],n=this.#e("readwrite"),t=this.#t(e,"update","unsynced");if(await i.put(n,t),navigator.onLine){let d=this.options.updatePath,s=await this.#n("PUT",d,e,o);return this.dispatchEvent(new MessageEvent("updated",{data:s})),s}return t}async delete(e){if(e.startsWith("TMP-")){let s=this.#e("readwrite");await i.del(s,e);return}let o=this.#e("readonly"),n=await i.get(o,e),t=this.#e("readwrite"),d=this.#t(n,"delete","unsynced");if(await i.put(t,d),navigator.onLine){let s=this.options.deletePath;await this.#n("DELETE",s,void 0,e),this.dispatchEvent(new MessageEvent("deleted",{data:e}))}}async readAll(e=!1){let n=this.db.transaction(this.storeName,"readonly").objectStore(this.storeName),t=await i.getAll(n);if(navigator.onLine&&(t.length===0||e)){let d=new URL(this.options.url+this.options.readAllPath),s;if(this.options.dryRun?(console.log(`DRY RUN: GET ${d}`),s=new Response(JSON.stringify(t),{status:200,headers:{"Content-Type":"application/json"}})):s=await fetch(d,{method:"GET",mode:"cors",credentials:"include"}),s.ok){let f=await s.json()??[],l=this.#e("readwrite"),c=(f??[]).map(r=>this.#t(r,"none","synced"));await i.putBulk(l,c);let p=t.filter(r=>r[this.options.keyName].startsWith("TMP-"));t=[...c,...p]}else console.log("fetch entries failed",s)}return this.dispatchEvent(new MessageEvent("readAll",{data:t})),t}async sync(e=null){if(!navigator.onLine)return;e===null&&(e=this.lastSync);let s=this.db.transaction(this.storeName,"readonly").objectStore(this.storeName).index("syncState").objectStore,l=(await i.getAll(s)).filter(a=>a.sync_state==="unsynced");if(l.length===0)return;let c=this.options.keyName,p=l.filter(a=>a.sync_action==="create").map(a=>a[c]),r=l.reduce((a,u)=>{if("sync_action"in u){let{sync_action:h}=u;h!==void 0&&(a[h]||(a[h]=[]),a[h].push(u))}return a},{}),g=new URL(this.options.url+this.options.syncPath);g.searchParams.set("t",e.toString());let m;if(this.options.dryRun){let a=[];"delete"in r&&(a=r.delete.map(y=>y[c]));let u=[];"update"in r&&(u=JSON.parse(JSON.stringify(r.update)));let h=[];"create"in r&&(h=JSON.parse(JSON.stringify(r.create)).map(y=>(y[c]=w(3),y))),console.log(`DRY RUN: POST ${g}`),m=new Response(JSON.stringify({deleted:a,changed:[...u,...h],timestamp:Date.now()}),{status:200,headers:{"Content-Type":"application/json"}})}else m=await fetch(g,{method:"POST",headers:{"Content-Type":"application/json"},body:JSON.stringify(r),mode:"cors",credentials:"include"});if(m.ok){let a=await m.json(),u=this.#e("readwrite"),h=a.changed.map(y=>this.#t(y,"none","synced"));await Promise.all([i.delBulk(u,p),i.delBulk(u,a.deleted),i.putBulk(u,h)]),this.dispatchEvent(new MessageEvent("synced",{data:a})),this.lastSync=new Date(a.timestamp).getTime()}else console.log("sync failed",m)}#t(e,o,n){return{...e,sync_action:o,sync_state:n}}#e(e){return this.db.transaction(this.storeName,e).objectStore(this.storeName)}#s(e,o){let n=new URL(this.options.url+e);return o.startsWith("TMP-")||n.searchParams.set(this.options.keyName,o),n}#n=async(e,o,n,t)=>{let s=e!=="GET"&&e!=="DELETE"?JSON.stringify(n):void 0,f=this.#s(o,t),l;if(this.options.dryRun){let c=JSON.parse(s),p=200;if(e==="POST"){let r=w(3);c[this.options.keyName]=r,p=201}else e==="DELETE"?p=204:e==="PUT"&&(p=200);console.log(`DRY RUN: ${e} ${f}`),l=new Response(JSON.stringify(c),{status:p,headers:{"Content-Type":"application/json"}})}else l=await fetch(f,{method:e,body:s,mode:"cors",credentials:"include"});if(l.ok){let c=this.#e("readwrite");if(e==="DELETE"){await i.del(c,t);return}else{let p=await l.json(),r=this.#t(p,"none","synced");return await i.put(c,r),r}}else if(l.status===404){let c=this.#e("readwrite");await i.del(c,t)}else console.log("read/write/delete entry failed",l)}};export{x as SyncedDB};
//# sourceMappingURL=synceddb.js.map
