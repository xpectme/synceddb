import*as o from"npm:idbx";var v=0,g=0;function E(S=1){let m=Date.now();return m===v?g++:(v=m,g=0),`${m}${g.toString().padStart(S,"0")}`}var w=class extends EventTarget{constructor(e,s,n){super();this.db=e;this.storeName=s;this.options={keyName:"id",url:location?.origin??"",autoSync:!1,createPath:"/api/create",readPath:"/api/read",updatePath:"/api/update",deletePath:"/api/delete",readAllPath:"/api/read_all",syncPath:"/api/sync",testRun:!1,...n},globalThis.addEventListener("online",()=>{this.syncState=new Promise(t=>{this.sync().then(()=>t("synced")).catch(console.error)})}),globalThis.addEventListener("offline",()=>{this.syncState=Promise.resolve("unsynced")})}static createStore(e,s,n){let t=e.createObjectStore(s,{keyPath:"id",autoIncrement:!1,...n});return t.createIndex("primaryKey","id",{unique:!0}),t.createIndex("syncState","sync_state",{unique:!1}),t.createIndex("syncAction","sync_action",{unique:!1}),t}options;syncState=Promise.resolve("unsynced");lastSync=0;async create(e){let s=this.#e("readwrite"),n=this.#t(e,"create","unsynced"),t;if(s.autoIncrement?(t=await o.add(s,n),e[this.options.keyName]=t,console.log("key",t)):(t="TMP-"+crypto.randomUUID(),e[this.options.keyName]=n[this.options.keyName]=t,await o.add(s,n)),navigator.onLine){let d=this.options.createPath,a=await this.#n("POST",d,e,t);return this.dispatchEvent(new MessageEvent("created",{data:a})),a}return n}async read(e,s=!1){let n=this.#e("readonly"),t=await o.get(n,e);if(t||(s=!0),navigator.onLine&&t?.sync_action==="create"||navigator.onLine&&s){let d=this.options.readPath,a=await this.#n("GET",d,void 0,e);return this.dispatchEvent(new MessageEvent("read",{data:a})),a}return this.dispatchEvent(new MessageEvent("read",{data:t})),t}async update(e){if(!e[this.options.keyName])throw new Error("Missing key");let s=e[this.options.keyName],n=this.#e("readwrite"),t=this.#t(e,"update","unsynced");if(await o.put(n,t),navigator.onLine){let d=this.options.updatePath,a=await this.#n("PUT",d,e,s);return this.dispatchEvent(new MessageEvent("updated",{data:a})),a}return t}async delete(e){let s=this.#e("readonly"),n=await o.get(s,e);if(n?.sync_action==="create"){let a=this.#e("readwrite");await o.del(a,e);return}let t=this.#e("readwrite"),d=this.#t(n,"delete","unsynced");if(await o.put(t,d),navigator.onLine){let a=this.options.deletePath;await this.#n("DELETE",a,void 0,e),this.dispatchEvent(new MessageEvent("deleted",{data:e}))}}async readAll(e=!1){let s=this.#e("readonly"),n=await o.getAll(s);if(navigator.onLine&&(n.length===0||e)){let t=new URL(this.options.url+this.options.readAllPath),d;if(this.options.testRun?(console.log(`TEST RUN: GET ${t}`),d=new Response(JSON.stringify(n),{status:200,headers:{"Content-Type":"application/json"}})):d=await fetch(t,{method:"GET",mode:"cors",credentials:"include"}),d.ok){let h=(await d.json()??[]??[]).map(i=>this.#t(i,"none","synced")),l=n.filter(i=>!h.some(p=>p[this.options.keyName]===i[this.options.keyName])).map(i=>i[this.options.keyName]),c=h.filter(i=>n.some(p=>p[this.options.keyName]===i[this.options.keyName]));return await o.batch(this.db,[{method:"del",keys:l,storeName:this.storeName},{method:"put",data:c,storeName:this.storeName}],"readwrite").completed,n=await o.getAll(this.#e("readonly")),this.dispatchEvent(new MessageEvent("readAll",{data:n})),n}else console.log("fetch entries failed",d)}return this.dispatchEvent(new MessageEvent("readAll",{data:n})),n}async sync(e=null){if(!navigator.onLine)return;e===null&&(e=this.lastSync);let d=this.#e("readonly").index("syncState").objectStore,h=(await o.getAll(d)).filter(r=>r.sync_state==="unsynced");if(h.length===0)return;let l=this.options.keyName,c=h.filter(r=>r.sync_action==="create").map(r=>r[l]),i=h.reduce((r,u)=>{if("sync_action"in u){let{sync_action:y}=u;y!==void 0&&(r[y]||(r[y]=[]),r[y].push(u))}return r},{}),p=new URL(this.options.url+this.options.syncPath);p.searchParams.set("t",e.toString());let f;if(this.options.testRun){let r=[];"delete"in i&&(r=i.delete.map(T=>T[l]));let u=[];"update"in i&&(u=JSON.parse(JSON.stringify(i.update)));let y=[];"create"in i&&(y=JSON.parse(JSON.stringify(i.create)).map(T=>(T[l]=E(3),T))),console.log(`TEST RUN: POST ${p}`),f=new Response(JSON.stringify({deleted:r,changed:[...u,...y],timestamp:Date.now()}),{status:200,headers:{"Content-Type":"application/json"}})}else f=await fetch(p,{method:"POST",headers:{"Content-Type":"application/json"},body:JSON.stringify(i),mode:"cors",credentials:"include"});if(f.ok){let r=await f.json(),u=r.changed.map(y=>this.#t(y,"none","synced"));await o.batch(this.db,[{method:"del",storeName:this.storeName,keys:c},{method:"del",storeName:this.storeName,keys:r.deleted},{method:"put",storeName:this.storeName,data:u}],"readwrite").completed,this.dispatchEvent(new MessageEvent("synced",{data:r})),this.lastSync=new Date(r.timestamp).getTime()}else console.log("sync failed",f)}#t(e,s,n){return{...e,sync_action:s,sync_state:n}}#e(e){return this.db.transaction(this.storeName,e).objectStore(this.storeName)}#s(e,s){let n=new URL(this.options.url+e);return s&&n.searchParams.set(this.options.keyName,s.toString()),n}#n=async(e,s,n,t)=>{let a=e!=="GET"&&e!=="DELETE"?JSON.stringify(n):void 0,h=this.#s(s,t),l;if(this.options.testRun){let c=a?JSON.parse(a):null,i=200,p=new Headers({"Content-Type":"application/json"});if(e==="POST"){let f=t??E(3);c!==null&&this.options.keyName in c&&(c[this.options.keyName]=f),i=201}else e==="DELETE"?(i=204,p.delete("Content-Type")):e==="PUT"&&(i=200);c!==null&&(c=JSON.stringify(c)),console.log(`TEST RUN: ${e} ${h}`),l=new Response(c,{status:i,headers:p})}else l=await fetch(h.toString(),{method:e,body:a,mode:"cors",credentials:"include"});if(l.ok)if(e==="DELETE"&&t){await o.del(this.#e("readwrite"),t);return}else{let c=await l.json(),i=this.#t(c,"none","synced");return await o.put(this.#e("readwrite"),i),i}else l.status===404?t&&await o.del(this.#e("readwrite"),t):console.log("read/write/delete entry failed",l)}};export{w as SyncedDB};
//# sourceMappingURL=synceddb.js.map
