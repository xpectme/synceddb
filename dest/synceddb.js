import*as i from"npm:idbx";var v=0,S=0;function w(g=1){let m=Date.now();return m===v?S++:(v=m,S=0),`${m}${S.toString().padStart(g,"0")}`}var E=class extends EventTarget{constructor(e,s,n){super();this.db=e;this.storeName=s;this.options={keyName:"id",url:location?.origin??"",autoSync:!1,createPath:"/api/create",readPath:"/api/read",updatePath:"/api/update",deletePath:"/api/delete",readAllPath:"/api/read_all",syncPath:"/api/sync",testRun:!1,...n},globalThis.addEventListener("online",()=>{this.syncState=new Promise(t=>{this.sync().then(()=>t("synced")).catch(console.error)})}),globalThis.addEventListener("offline",()=>{this.syncState=Promise.resolve("unsynced")})}static createStore(e,s,n){let t=e.createObjectStore(s,{keyPath:"id",autoIncrement:!1,...n});return t.createIndex("syncState","sync_state",{unique:!1}),t.createIndex("syncAction","sync_action",{unique:!1}),t}options;syncState=Promise.resolve("unsynced");lastSync=0;async create(e){let s=this.#e("readwrite"),n=this.#t(e,"create","unsynced"),t;if(s.autoIncrement?(t=await i.add(s,n),n[this.options.keyName]=t,console.log("key",t)):(t="TMP-"+crypto.randomUUID(),n[this.options.keyName]=t,await i.add(s,n)),navigator.onLine){let d=this.options.createPath,a=await this.#n("POST",d,e,t);return this.dispatchEvent(new MessageEvent("created",{data:a})),a}return n}async read(e,s=!1){let n=this.#e("readonly"),t=await i.get(n,e);if(t||(s=!0),navigator.onLine&&t?.sync_action==="create"||navigator.onLine&&s){let d=this.options.readPath,a=await this.#n("GET",d,void 0,e);return this.dispatchEvent(new MessageEvent("read",{data:a})),a}return this.dispatchEvent(new MessageEvent("read",{data:t})),t}async update(e){if(!e[this.options.keyName])throw new Error("Missing key");let s=e[this.options.keyName],n=this.#e("readwrite"),t=this.#t(e,"update","unsynced");if(await i.put(n,t),navigator.onLine){let d=this.options.updatePath,a=await this.#n("PUT",d,e,s);return this.dispatchEvent(new MessageEvent("updated",{data:a})),a}return t}async delete(e){let s=this.#e("readonly"),n=await i.get(s,e);if(n?.sync_action==="create"){let a=this.#e("readwrite");await i.del(a,e);return}let t=this.#e("readwrite"),d=this.#t(n,"delete","unsynced");if(await i.put(t,d),navigator.onLine){let a=this.options.deletePath;await this.#n("DELETE",a,void 0,e),this.dispatchEvent(new MessageEvent("deleted",{data:e}))}}async readAll(e=!1){let s=this.#e("readonly"),n=await i.getAll(s);if(navigator.onLine&&(n.length===0||e)){let t=new URL(this.options.url+this.options.readAllPath),d;if(this.options.testRun?(console.log(`TEST RUN: GET ${t}`),d=new Response(JSON.stringify(n),{status:200,headers:{"Content-Type":"application/json"}})):d=await fetch(t,{method:"GET",mode:"cors",credentials:"include"}),d.ok){let a=await d.json()??[],u=this.#e("readwrite"),c=(a??[]).map(o=>this.#t(o,"none","synced"));await i.putBulk(u,c);let l=n.filter(o=>o.sync_action==="create");n=[...c,...l]}else console.log("fetch entries failed",d)}return this.dispatchEvent(new MessageEvent("readAll",{data:n})),n}async sync(e=null){if(!navigator.onLine)return;e===null&&(e=this.lastSync);let d=this.#e("readonly").index("syncState").objectStore,u=(await i.getAll(d)).filter(r=>r.sync_state==="unsynced");if(u.length===0)return;let c=this.options.keyName,l=u.filter(r=>r.sync_action==="create").map(r=>r[c]),o=u.reduce((r,y)=>{if("sync_action"in y){let{sync_action:p}=y;p!==void 0&&(r[p]||(r[p]=[]),r[p].push(y))}return r},{}),h=new URL(this.options.url+this.options.syncPath);h.searchParams.set("t",e.toString());let f;if(this.options.testRun){let r=[];"delete"in o&&(r=o.delete.map(T=>T[c]));let y=[];"update"in o&&(y=JSON.parse(JSON.stringify(o.update)));let p=[];"create"in o&&(p=JSON.parse(JSON.stringify(o.create)).map(T=>(T[c]=w(3),T))),console.log(`TEST RUN: POST ${h}`),f=new Response(JSON.stringify({deleted:r,changed:[...y,...p],timestamp:Date.now()}),{status:200,headers:{"Content-Type":"application/json"}})}else f=await fetch(h,{method:"POST",headers:{"Content-Type":"application/json"},body:JSON.stringify(o),mode:"cors",credentials:"include"});if(f.ok){let r=await f.json(),y=r.changed.map(p=>this.#t(p,"none","synced"));await i.batch(this.db,[{method:"del",storeName:this.storeName,keys:l},{method:"del",storeName:this.storeName,keys:r.deleted},{method:"put",storeName:this.storeName,data:y}],"readwrite").completed,this.dispatchEvent(new MessageEvent("synced",{data:r})),this.lastSync=new Date(r.timestamp).getTime()}else console.log("sync failed",f)}#t(e,s,n){return{...e,sync_action:s,sync_state:n}}#e(e){return this.db.transaction(this.storeName,e).objectStore(this.storeName)}#s(e,s){let n=new URL(this.options.url+e);return s&&n.searchParams.set(this.options.keyName,s.toString()),n}#n=async(e,s,n,t)=>{let a=e!=="GET"&&e!=="DELETE"?JSON.stringify(n):void 0,u=this.#s(s,t),c;if(this.options.testRun){let l=a?JSON.parse(a):null,o=200,h=new Headers({"Content-Type":"application/json"});if(e==="POST"){let f=w(3);l!==null&&this.options.keyName in l&&(l[this.options.keyName]=f),o=201}else e==="DELETE"?(o=204,h.delete("Content-Type")):e==="PUT"&&(o=200);l!==null&&(l=JSON.stringify(l)),console.log(`TEST RUN: ${e} ${u}`),c=new Response(l,{status:o,headers:h})}else c=await fetch(u,{method:e,body:a,mode:"cors",credentials:"include"});if(c.ok)if(e==="DELETE"&&t){await i.del(this.#e("readwrite"),t);return}else{let l=await c.json(),o=this.#t(l,"none","synced");return this.#e("readwrite").autoIncrement?await i.put(this.#e("readwrite"),o):await i.put(this.#e("readwrite"),o,t),o}else c.status===404?t&&await i.del(this.#e("readwrite"),t):console.log("read/write/delete entry failed",c)}};export{E as SyncedDB};
//# sourceMappingURL=synceddb.js.map
