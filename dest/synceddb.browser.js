import*as n from"https://esm.sh/idbx@v1.0.4?dts";var g=class{constructor(t,i,s){this.db=t;this.storeName=i;this.options={keyName:"id",url:globalThis.location?.origin??"",autoSync:!1,createPath:"/api/create",readPath:"/api/read",updatePath:"/api/update",deletePath:"/api/delete",readAllPath:"/api/read_all",syncPath:"/api/sync",...s},globalThis.addEventListener("online",()=>{this.syncState=new Promise(e=>{this.sync().then(()=>e("synced")).catch(console.error)})}),globalThis.addEventListener("offline",()=>{this.syncState=Promise.resolve("unsynced")})}static createStore(t,i,s="id"){let e=t.createObjectStore(i,{keyPath:s,autoIncrement:!1});return e.createIndex("syncState","sync_state",{unique:!1}),e.createIndex("syncAction","sync_action",{unique:!1}),e}options;syncState=Promise.resolve("unsynced");lastSync=0;async create(t){let i=this.#t("readwrite"),s=this.#e(t,"create","unsynced"),e="TMP-"+crypto.randomUUID();return s[this.options.keyName]=e,await n.add(i,s),navigator.onLine?this.#s("POST",this.options.createPath,t,e):s}async read(t,i=!1){let s=this.#t("readonly"),e=await n.get(s,t);return e||(i=!0),navigator.onLine&&!t.startsWith("TMP-")&&i?this.#s("GET",this.options.readPath,void 0,t):e}async update(t){if(!t[this.options.keyName])throw new Error("Missing key");let i=t[this.options.keyName],s=this.#t("readwrite"),e=this.#e(t,"update","unsynced");return await n.put(s,e),navigator.onLine?this.#s("PUT",this.options.updatePath,t,i):e}async delete(t){if(t.startsWith("TMP-")){let r=this.#t("readwrite");await n.del(r,t);return}let i=this.#t("readonly"),s=await n.get(i,t),e=this.#t("readwrite"),h=this.#e(s,"delete","unsynced");await n.put(e,h),navigator.onLine&&await this.#s("DELETE",this.options.deletePath,void 0,t)}async readAll(t=!1){let s=this.db.transaction(this.storeName,"readonly").objectStore(this.storeName),e=await n.getAll(s);if(navigator.onLine&&(e.length===0||t)){let h=new URL(this.options.url+this.options.readAllPath),r=await fetch(h,{method:"GET",mode:"cors",credentials:"include"});if(r.ok){let p=await r.json()??[],a=this.#t("readwrite"),c=(p??[]).map(d=>this.#e(d,"none","synced"));await n.putBulk(a,c);let u=e.filter(d=>d[this.options.keyName].startsWith("TMP-"));return[...c,...u]}else console.log("fetch entries failed",r)}return e}async sync(t=null){if(!navigator.onLine)return;t===null&&(t=this.lastSync);let r=this.db.transaction(this.storeName,"readonly").objectStore(this.storeName).index("syncState").objectStore,a=(await n.getAll(r)).filter(o=>o.sync_state==="unsynced");if(a.length===0)return;let c=this.options.keyName,u=a.filter(o=>o.sync_action==="create").map(o=>o[c]),d=a.reduce((o,l)=>{let{sync_action:y}=l;return o[y]||(o[y]=[]),o[y].push(l),o},{}),m=new URL(this.options.url+this.options.syncPath);m.searchParams.set("t",t.toString());let f=await fetch(m,{method:"POST",headers:{"Content-Type":"application/json"},body:JSON.stringify(d),mode:"cors",credentials:"include"});if(f.ok){let o=await f.json(),l=this.#t("readwrite"),y=o.changed.map(b=>this.#e(b,"none","synced"));await Promise.all([n.delBulk(l,u),n.delBulk(l,o.deleted),n.putBulk(l,y)]),this.lastSync=new Date(o.timestamp).getTime()}else console.log("sync failed",f)}#e(t,i,s){return{...t,sync_action:i,sync_state:s}}#t(t){return this.db.transaction(this.storeName,t).objectStore(this.storeName)}#n(t,i){let s=new URL(this.options.url+t);return i.startsWith("TMP-")||s.searchParams.set(this.options.keyName,i),s}#s=async(t,i,s,e)=>{let r=t!=="GET"&&t!=="DELETE"?JSON.stringify(s):void 0,p=this.#n(i,e),a=await fetch(p,{method:t,body:r,mode:"cors",credentials:"include"});if(console.log(a.ok,a.status),a.ok){let c=this.#t("readwrite");if(t==="DELETE"){await n.del(c,e);return}else{let u=await a.json(),d=this.#e(u,"none","synced");return await n.put(c,d),d}}else if(a.status===404){let c=this.#t("readwrite");await n.del(c,e)}else console.log("read/write/delete entry failed",a)}};export{g as SyncedDB};
//# sourceMappingURL=synceddb.browser.js.map
