{
  "version": 3,
  "sources": ["../lib/SyncedDB.ts"],
  "sourcesContent": ["import * as idbx from \"npm:idbx\";\nimport idbatch from \"npm:idbatch\";\nimport { SyncedDBOptions } from \"./SyncedDBOptions.ts\";\nimport { SyncedDBAction } from \"./SyncedDBAction.ts\";\nimport { SyncedDBState } from \"./SyncedDBState.ts\";\nimport { SyncedDBResponse } from \"./SyncedDBResponse.ts\";\nimport { SyncedDBRequest } from \"./SyncedDBRequest.ts\";\nimport { SyncedDBInfo } from \"./SyncedDBInfo.ts\";\nimport { SyncedDBEventMap } from \"./SyncedDBEventMap.ts\";\nimport { SyncedDBEventTarget } from \"./SyncedDBEventTarget.ts\";\n\nlet currentTime = 0;\nlet currentCount = 0;\nfunction testRunId(padding = 1) {\n  const now = Date.now();\n  if (now === currentTime) {\n    currentCount++;\n  } else {\n    currentTime = now;\n    currentCount = 0;\n  }\n  return `${now}${currentCount.toString().padStart(padding, \"0\")}`;\n}\n\nexport interface SyncedDB<T extends SyncedDBInfo>\n  extends SyncedDBEventTarget<T> {\n  addEventListener<K extends keyof SyncedDBEventMap<T>>(\n    type: K,\n    listener: ((ev: SyncedDBEventMap<T>[K]) => void) | null,\n    options?: boolean | AddEventListenerOptions,\n  ): void;\n  addEventListener(\n    type: string,\n    callback: EventListenerOrEventListenerObject | null,\n    options?: EventListenerOptions | boolean,\n  ): void;\n\n  removeEventListener<K extends keyof SyncedDBEventMap<T>>(\n    type: K,\n    listener: ((ev: SyncedDBEventMap<T>[K]) => void) | null,\n    options?: boolean | EventListenerOptions,\n  ): void;\n  removeEventListener(\n    type: string,\n    callback: EventListenerOrEventListenerObject | null,\n    options?: EventListenerOptions | boolean,\n  ): void;\n\n  dispatchEvent(event: Event): boolean;\n}\n\nexport class SyncedDB<T extends SyncedDBInfo>\n  extends (EventTarget as unknown as {\n    // deno-lint-ignore no-explicit-any\n    new (): SyncedDBEventTarget<any>;\n    // deno-lint-ignore no-explicit-any\n    prototype: SyncedDBEventTarget<any>;\n  }) {\n  static createStore(\n    db: IDBDatabase,\n    storeName: string,\n    options?: IDBObjectStoreParameters,\n  ) {\n    const store = db.createObjectStore(\n      storeName,\n      {\n        keyPath: \"id\",\n        autoIncrement: false,\n        ...options,\n      },\n    );\n    store.createIndex(\"primaryKey\", \"id\", { unique: true });\n    store.createIndex(\"syncState\", \"sync_state\", { unique: false });\n    store.createIndex(\"syncAction\", \"sync_action\", { unique: false });\n    return store;\n  }\n\n  options: SyncedDBOptions;\n\n  syncState = Promise.resolve(\"unsynced\");\n  lastSync = 0;\n\n  constructor(\n    public db: IDBDatabase,\n    public storeName: string,\n    options?: Partial<SyncedDBOptions>,\n  ) {\n    super();\n    this.options = {\n      keyName: \"id\",\n      url: location?.origin ?? \"\",\n      autoSync: false,\n      createPath: \"/api/create\",\n      readPath: \"/api/read\",\n      updatePath: \"/api/update\",\n      deletePath: \"/api/delete\",\n      readAllPath: \"/api/read_all\",\n      syncPath: \"/api/sync\",\n      testRun: false,\n      ...options,\n    };\n    globalThis.addEventListener(\"online\", () => {\n      this.syncState = new Promise((resolve) => {\n        this.sync()\n          .then(() => resolve(\"synced\"))\n          .catch(console.error);\n      });\n    });\n    globalThis.addEventListener(\"offline\", () => {\n      this.syncState = Promise.resolve(\"unsynced\");\n    });\n  }\n\n  // create a method that writes into the indexeddb store and send a fetch\n  // request to the server to update the database on the server\n  async create(data: T) {\n    const store = idbx.getStore(this.db, this.storeName, \"readwrite\");\n    const item = this.#addSyncState(data, \"create\", \"unsynced\");\n    let key: IDBValidKey;\n    if (store.autoIncrement) {\n      key = await idbx.add(store, item);\n      data[this.options.keyName] = key;\n    } else {\n      key = \"TMP-\" + crypto.randomUUID();\n      data[this.options.keyName] = item[this.options.keyName] = key;\n      await idbx.add(store, item);\n    }\n\n    if (navigator.onLine) {\n      const path = this.options.createPath;\n      const result = await this.#fetchOne(\"POST\", path, data, key);\n      this.dispatchEvent(new MessageEvent(\"created\", { data: result }));\n      return result;\n    }\n    return item as T;\n  }\n\n  // create a method that reads from the indexeddb store and send a fetch\n  // request to the server to update the database on the server\n  async read(key: string, forceSync = false) {\n    const store = idbx.getStore(this.db, this.storeName);\n    const result = await idbx.get<T>(store, key);\n\n    if (!result) {\n      // sync if result is not found\n      forceSync = true;\n    }\n\n    if (\n      navigator.onLine && result?.sync_action === \"create\" ||\n      navigator.onLine && forceSync\n    ) {\n      const path = this.options.readPath;\n      const result = await this.#fetchOne(\"GET\", path, undefined, key);\n      this.dispatchEvent(new MessageEvent(\"read\", { data: result }));\n      return result;\n    }\n\n    this.dispatchEvent(new MessageEvent(\"read\", { data: result }));\n    return result;\n  }\n\n  // create a method that updates the indexeddb store and send a fetch\n  // request to the server to update the database on the server\n  async update(data: T) {\n    if (!data[this.options.keyName]) {\n      throw new Error(\"Missing key\");\n    }\n    const key = data[this.options.keyName] as string;\n\n    const store = idbx.getStore(this.db, this.storeName, \"readwrite\");\n    const item = this.#addSyncState(data, \"update\", \"unsynced\");\n    await idbx.put(store, item);\n\n    if (navigator.onLine) {\n      const path = this.options.updatePath;\n      const result = await this.#fetchOne(\"PUT\", path, data, key);\n      this.dispatchEvent(new MessageEvent(\"updated\", { data: result }));\n      return result;\n    }\n    return item as T;\n  }\n\n  // create a method that deletes from the indexeddb store and send a fetch\n  // request to the server to update the database on the server\n  async delete(key: string) {\n    const read = idbx.getStore(this.db, this.storeName);\n    const record = await idbx.get<T>(read, key);\n\n    // check if the record is already registered on the server.\n    // If it isn't, then we can delete it from the store right now.\n    if (record?.sync_action === \"create\") {\n      // delete the record\n      const store = idbx.getStore(this.db, this.storeName, \"readwrite\");\n      await idbx.del(store, key);\n      return;\n    }\n\n    const store = idbx.getStore(this.db, this.storeName, \"readwrite\");\n    const item = this.#addSyncState(record as T, \"delete\", \"unsynced\");\n    await idbx.put(store, item);\n\n    // delete the record\n    if (navigator.onLine) {\n      const path = this.options.deletePath;\n      await this.#fetchOne(\"DELETE\", path, undefined, key);\n      this.dispatchEvent(new MessageEvent(\"deleted\", { data: key }));\n    }\n  }\n\n  // create a method that reads all from the indexeddb store and send a fetch\n  // request to the server to update the database on the server\n  async readAll(forceSync = false) {\n    const store = idbx.getStore(this.db, this.storeName);\n    let result = await idbx.getAll<T>(store);\n\n    if (navigator.onLine && (result.length === 0 || forceSync)) {\n      const url = new URL(this.options.url + this.options.readAllPath);\n\n      let response: Response;\n      if (this.options.testRun) {\n        console.log(`TEST RUN: GET ${url}`);\n        response = new Response(JSON.stringify(result), {\n          status: 200,\n          headers: { \"Content-Type\": \"application/json\" },\n        });\n      } else {\n        response = await fetch(url, {\n          method: \"GET\",\n          mode: \"cors\",\n          credentials: \"include\",\n        });\n      }\n\n      if (response.ok) {\n        const json: T[] = await response.json() ?? [];\n        const items = (json ?? []).map((item) =>\n          this.#addSyncState(item, \"none\", \"synced\")\n        );\n\n        const deletables = result\n          .filter(\n            (item) =>\n              !items.some((i) =>\n                i[this.options.keyName] === item[this.options.keyName]\n              ),\n          ).map((item) => item[this.options.keyName]);\n\n        const updatables = items.filter((item) =>\n          result.some((i) =>\n            i[this.options.keyName] === item[this.options.keyName]\n          )\n        );\n\n        await idbatch(this.db, [\n          { method: \"del\", keys: deletables, storeName: this.storeName },\n          { method: \"put\", data: updatables, storeName: this.storeName },\n        ], \"readwrite\").completed;\n\n        const store = idbx.getStore(this.db, this.storeName);\n        result = await idbx.getAll<T>(store);\n        this.dispatchEvent(new MessageEvent(\"readAll\", { data: result }));\n        return result as T[];\n      } else {\n        // handle error\n        console.log(\"fetch entries failed\", response);\n      }\n    }\n\n    this.dispatchEvent(new MessageEvent(\"readAll\", { data: result }));\n    return result as T[];\n  }\n\n  async sync(timestamp: number | null = null) {\n    const offline = !navigator.onLine;\n    if (offline) {\n      return;\n    }\n\n    if (timestamp === null) {\n      timestamp = this.lastSync;\n    }\n\n    const store = idbx.getStore(this.db, this.storeName);\n    const index = store.index(\"syncState\");\n    const syncStore = index.objectStore;\n\n    const result = await idbx.getAll<T>(syncStore);\n    const unsynced = result.filter((item) => item.sync_state === \"unsynced\");\n\n    if (unsynced.length === 0) {\n      return;\n    }\n\n    // filter all items where keyName starts with TMP-\n    const key = this.options.keyName;\n    const createTmpIds = unsynced\n      .filter((item) => item.sync_action === \"create\")\n      .map<string>((item) => item[key]);\n\n    // create groups from sync_action\n    const groups = unsynced.reduce<SyncedDBRequest<T>>(\n      (acc, item) => {\n        if (\"sync_action\" in item) {\n          const { sync_action } = item;\n          if (sync_action !== undefined) {\n            if (!acc[sync_action]) {\n              acc[sync_action] = [];\n            }\n            acc[sync_action].push(item);\n          }\n        }\n        return acc;\n      },\n      {} as SyncedDBRequest<T>,\n    );\n\n    const url = new URL(this.options.url + this.options.syncPath);\n    url.searchParams.set(\"t\", timestamp.toString());\n\n    let response: Response;\n    if (this.options.testRun) {\n      // handle deletions\n      let deleted: string[] = [];\n      if (\"delete\" in groups) {\n        deleted = groups.delete.map((item: T) => item[key]);\n      }\n\n      // handle updates\n      let updated: T[] = [];\n      if (\"update\" in groups) {\n        updated = JSON.parse(JSON.stringify(groups.update));\n      }\n\n      // handle creations\n      let created: T[] = [];\n      if (\"create\" in groups) {\n        created = JSON.parse(JSON.stringify(groups.create)).map((item: T) => {\n          item[key] = testRunId(3);\n          return item;\n        });\n      }\n\n      console.log(`TEST RUN: POST ${url}`);\n      response = new Response(\n        JSON.stringify({\n          deleted,\n          changed: [...updated, ...created],\n          timestamp: Date.now(),\n        } as SyncedDBResponse<T>),\n        {\n          status: 200,\n          headers: { \"Content-Type\": \"application/json\" },\n        },\n      );\n    } else {\n      response = await fetch(url, {\n        method: \"POST\",\n        headers: { \"Content-Type\": \"application/json\" },\n        body: JSON.stringify(groups),\n        mode: \"cors\",\n        credentials: \"include\",\n      });\n    }\n\n    if (response.ok) {\n      const json = await response.json() as SyncedDBResponse<T>;\n      const items = this.#addSyncState(json.changed, \"none\", \"synced\");\n\n      await idbatch<T>(this.db, [\n        { method: \"del\", storeName: this.storeName, keys: createTmpIds },\n        { method: \"del\", storeName: this.storeName, keys: json.deleted },\n        { method: \"put\", storeName: this.storeName, data: items },\n      ], \"readwrite\").completed;\n\n      this.dispatchEvent(new MessageEvent(\"synced\", { data: json }));\n      this.lastSync = new Date(json.timestamp).getTime();\n    } else {\n      // handle error\n      console.log(\"sync failed\", response);\n    }\n  }\n\n  #addSyncState(\n    data: T | T[] | undefined,\n    sync_action: SyncedDBAction,\n    sync_state: SyncedDBState,\n  ) {\n    if (Array.isArray(data)) {\n      return data.map<T>((item) => ({ ...item, sync_action, sync_state } as T));\n    }\n    return { ...data, sync_action, sync_state } as T;\n  }\n\n  #buildUrl(path: string, key?: IDBValidKey | undefined) {\n    const url = new URL(this.options.url + path);\n    if (key) {\n      url.searchParams.set(this.options.keyName as string, key.toString());\n    }\n    return url;\n  }\n\n  #fetchOne = async (\n    method: string,\n    path: string,\n    data: T | undefined,\n    key?: IDBValidKey | undefined,\n  ) => {\n    const canHaveBody = method !== \"GET\" && method !== \"DELETE\";\n    const body = !canHaveBody ? undefined : JSON.stringify(data);\n    const url = this.#buildUrl(path, key);\n\n    let response: Response;\n    let isValid = !this.options.testRun;\n    if (this.options.testRun) {\n      let responseBody = body ? JSON.parse(body) : null;\n      let status = 200;\n      isValid = responseBody !== null;\n      const headers = new Headers({ \"Content-Type\": \"application/json\" });\n      if (\"POST\" === method) {\n        const id = key ?? testRunId(3);\n        if (responseBody !== null && this.options.keyName in responseBody) {\n          responseBody[this.options.keyName] = id;\n        }\n        status = 201;\n      } else if (\"DELETE\" === method) {\n        status = 204;\n        headers.delete(\"Content-Type\");\n      } else if (\"PUT\" === method) {\n        status = 200;\n      }\n\n      if (responseBody !== null) {\n        responseBody = JSON.stringify(responseBody);\n      }\n\n      console.log(`TEST RUN: ${method} ${url}`);\n      response = new Response(responseBody, { status, headers });\n    } else {\n      response = await fetch(url.toString(), {\n        method,\n        body,\n        mode: \"cors\",\n        credentials: \"include\",\n      });\n    }\n\n    if (response.ok && response.status >= 200 && response.status < 300) {\n      if (method === \"DELETE\" && key) {\n        const store = idbx.getStore(this.db, this.storeName, \"readwrite\");\n        await idbx.del(store, key);\n        return;\n      } else if (isValid) {\n        const json = await response.json();\n        const item = this.#addSyncState(json, \"none\", \"synced\");\n        const store = idbx.getStore(this.db, this.storeName, \"readwrite\");\n        await idbx.put(store, item);\n        return item as T;\n      }\n    } else if (response.status === 404) {\n      if (key) {\n        const store = idbx.getStore(this.db, this.storeName, \"readwrite\");\n        await idbx.del(store, key);\n      }\n    } else {\n      // handle error\n      console.log(\"read/write/delete entry failed\", response);\n    }\n  };\n}\n"],
  "mappings": "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",
  "names": ["idbx", "idbatch", "currentTime", "currentCount", "testRunId", "padding", "now", "SyncedDB", "db", "storeName", "options", "resolve", "store", "data", "item", "#addSyncState", "key", "path", "result", "#fetchOne", "forceSync", "read", "record", "url", "response", "items", "deletables", "i", "updatables", "timestamp", "syncStore", "unsynced", "createTmpIds", "groups", "acc", "sync_action", "deleted", "updated", "created", "json", "sync_state", "#buildUrl", "method", "body", "isValid", "responseBody", "status", "headers", "id"]
}
