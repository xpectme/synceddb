{
  "version": 3,
  "sources": ["../SyncedDB.ts"],
  "sourcesContent": ["import * as idbx from \"npm:idbx\";\nimport { SyncedDBOptions } from \"./SyncedDBOptions.ts\";\nimport { SyncedDBAction } from \"./SyncedDBAction.ts\";\nimport { SyncedDBState } from \"./SyncedDBState.ts\";\nimport { SyncedDBResponse } from \"./SyncedDBResponse.ts\";\nimport { SyncedDBRequest } from \"./SyncedDBRequest.ts\";\nimport { SyncedDBInfo } from \"./SyncedDBInfo.ts\";\nimport { SyncedDBEventMap } from \"./SyncedDBEventMap.ts\";\nimport { SyncedDBEventTarget } from \"./SyncedDBEventTarget.ts\";\n\nlet currentTime = 0;\nlet currentCount = 0;\nfunction dryRunId(padding = 1) {\n  const now = Date.now();\n  if (now === currentTime) {\n    currentCount++;\n  } else {\n    currentTime = now;\n    currentCount = 0;\n  }\n  return `${now}${currentCount.toString().padStart(padding, \"0\")}`;\n}\n\nexport interface SyncedDB<T extends SyncedDBInfo>\n  extends SyncedDBEventTarget<T> {\n  addEventListener<K extends keyof SyncedDBEventMap<T>>(\n    type: K,\n    listener: ((ev: SyncedDBEventMap<T>[K]) => void) | null,\n    options?: boolean | AddEventListenerOptions,\n  ): void;\n  addEventListener(\n    type: string,\n    callback: EventListenerOrEventListenerObject | null,\n    options?: EventListenerOptions | boolean,\n  ): void;\n\n  removeEventListener<K extends keyof SyncedDBEventMap<T>>(\n    type: K,\n    listener: ((ev: SyncedDBEventMap<T>[K]) => void) | null,\n    options?: boolean | EventListenerOptions,\n  ): void;\n  removeEventListener(\n    type: string,\n    callback: EventListenerOrEventListenerObject | null,\n    options?: EventListenerOptions | boolean,\n  ): void;\n}\n\nexport class SyncedDB<T extends SyncedDBInfo>\n  extends (EventTarget as unknown as {\n    // deno-lint-ignore no-explicit-any\n    new (): SyncedDBEventTarget<any>;\n    // deno-lint-ignore no-explicit-any\n    prototype: SyncedDBEventTarget<any>;\n  }) {\n  static createStore(\n    db: IDBDatabase,\n    storeName: string,\n    options?: IDBObjectStoreParameters,\n  ) {\n    const store = db.createObjectStore(\n      storeName,\n      options ?? {\n        keyPath: \"id\",\n        autoIncrement: false,\n      },\n    );\n    store.createIndex(\"syncState\", \"sync_state\", { unique: false });\n    store.createIndex(\"syncAction\", \"sync_action\", { unique: false });\n    return store;\n  }\n\n  options: SyncedDBOptions;\n\n  syncState = Promise.resolve(\"unsynced\");\n  lastSync = 0;\n\n  constructor(\n    public db: IDBDatabase,\n    public storeName: string,\n    options?: Partial<SyncedDBOptions>,\n  ) {\n    super();\n    this.options = {\n      keyName: \"id\",\n      url: location?.origin ?? \"\",\n      autoSync: false,\n      createPath: \"/api/create\",\n      readPath: \"/api/read\",\n      updatePath: \"/api/update\",\n      deletePath: \"/api/delete\",\n      readAllPath: \"/api/read_all\",\n      syncPath: \"/api/sync\",\n      dryRun: false,\n      ...options,\n    };\n    globalThis.addEventListener(\"online\", () => {\n      this.syncState = new Promise((resolve) => {\n        this.sync()\n          .then(() => resolve(\"synced\"))\n          .catch(console.error);\n      });\n    });\n    globalThis.addEventListener(\"offline\", () => {\n      this.syncState = Promise.resolve(\"unsynced\");\n    });\n  }\n\n  // create a method that writes into the indexeddb store and send a fetch\n  // request to the server to update the database on the server\n  async create(data: T) {\n    const store = this.#getStore(\"readwrite\");\n    const item = this.#addSyncState(data, \"create\", \"unsynced\");\n    let key: string | undefined;\n    if (!store.autoIncrement) {\n      key = \"TMP-\" + crypto.randomUUID();\n      item[this.options.keyName] = key;\n    }\n    await idbx.add(store, item);\n\n    if (navigator.onLine) {\n      const path = this.options.createPath;\n      const result = await this.#fetchOne(\"POST\", path, data, key);\n      this.dispatchEvent(new MessageEvent(\"created\", { data: result }));\n      return result;\n    }\n    return item as T;\n  }\n\n  // create a method that reads from the indexeddb store and send a fetch\n  // request to the server to update the database on the server\n  async read(key: string, forceSync = false) {\n    const store = this.#getStore(\"readonly\");\n    const result = await idbx.get<T>(store, key);\n\n    if (!result) {\n      // sync if result is not found\n      forceSync = true;\n    }\n\n    if (navigator.onLine && result?.sync_action === \"create\" || navigator.onLine && forceSync) {\n      const path = this.options.readPath;\n      const result = await this.#fetchOne(\"GET\", path, undefined, key);\n      this.dispatchEvent(new MessageEvent(\"read\", { data: result }));\n      return result;\n    }\n\n    this.dispatchEvent(new MessageEvent(\"read\", { data: result }));\n    return result;\n  }\n\n  // create a method that updates the indexeddb store and send a fetch\n  // request to the server to update the database on the server\n  async update(data: T) {\n    if (!data[this.options.keyName]) {\n      throw new Error(\"Missing key\");\n    }\n    const key = data[this.options.keyName] as string;\n\n    const store = this.#getStore(\"readwrite\");\n    const item = this.#addSyncState(data, \"update\", \"unsynced\");\n    await idbx.put(store, item);\n\n    if (navigator.onLine) {\n      const path = this.options.updatePath;\n      const result = await this.#fetchOne(\"PUT\", path, data, key);\n      this.dispatchEvent(new MessageEvent(\"updated\", { data: result }));\n      return result;\n    }\n    return item as T;\n  }\n\n  // create a method that deletes from the indexeddb store and send a fetch\n  // request to the server to update the database on the server\n  async delete(key: string) {\n    const read = this.#getStore(\"readonly\");\n    const record = await idbx.get<T>(read, key);\n\n    // check if the record is already registered on the server.\n    // If it isn't, then we can delete it from the store right now.\n    if (record?.sync_action === \"create\") {\n      // delete the record\n      const store = this.#getStore(\"readwrite\");\n      await idbx.del(store, key);\n      return;\n    }\n\n    const store = this.#getStore(\"readwrite\");\n    const item = this.#addSyncState(record as T, \"delete\", \"unsynced\");\n    await idbx.put(store, item);\n\n    // delete the record\n    if (navigator.onLine) {\n      const path = this.options.deletePath;\n      await this.#fetchOne(\"DELETE\", path, undefined, key);\n      this.dispatchEvent(new MessageEvent(\"deleted\", { data: key }));\n    }\n  }\n\n  // create a method that reads all from the indexeddb store and send a fetch\n  // request to the server to update the database on the server\n  async readAll(forceSync = false) {\n    const tx = this.db.transaction(this.storeName, \"readonly\");\n    const store = tx.objectStore(this.storeName);\n    let result = await idbx.getAll<T>(store);\n\n    if (navigator.onLine && (result.length === 0 || forceSync)) {\n      const url = new URL(this.options.url + this.options.readAllPath);\n\n      let response: Response;\n      if (this.options.dryRun) {\n        console.log(`DRY RUN: GET ${url}`);\n        response = new Response(JSON.stringify(result), {\n          status: 200,\n          headers: { \"Content-Type\": \"application/json\" },\n        });\n      } else {\n        response = await fetch(url, {\n          method: \"GET\",\n          mode: \"cors\",\n          credentials: \"include\",\n        });\n      }\n\n      if (response.ok) {\n        const json: T[] = await response.json() ?? [];\n        const store = this.#getStore(\"readwrite\");\n        const items = (json ?? []).map((item) =>\n          this.#addSyncState(item, \"none\", \"synced\")\n        );\n\n        await idbx.putBulk(store, items);\n\n        // add the TMP- items to the items array\n        const tmpItems = result.filter((item) => item.sync_action === \"create\");\n        result = [...items, ...tmpItems] as T[];\n      } else {\n        // handle error\n        console.log(\"fetch entries failed\", response);\n      }\n    }\n\n    this.dispatchEvent(new MessageEvent(\"readAll\", { data: result }));\n    return result as T[];\n  }\n\n  async sync(timestamp: number | null = null) {\n    const offline = !navigator.onLine;\n    if (offline) {\n      return;\n    }\n\n    if (timestamp === null) {\n      timestamp = this.lastSync;\n    }\n\n    const tx = this.db.transaction(this.storeName, \"readonly\");\n    const store = tx.objectStore(this.storeName);\n    const index = store.index(\"syncState\");\n    const syncStore = index.objectStore;\n\n    const result = await idbx.getAll<T>(syncStore);\n    const unsynced = result.filter((item) => item.sync_state === \"unsynced\");\n\n    if (unsynced.length === 0) {\n      return;\n    }\n\n    // filter all items where keyName starts with TMP-\n    const key = this.options.keyName;\n    const createTmpIds = unsynced\n      .filter((item) => item.sync_action === \"create\")\n      .map<string>((item) => item[key]);\n\n    // create groups from sync_action\n    const groups = unsynced.reduce<SyncedDBRequest<T>>(\n      (acc, item) => {\n        if (\"sync_action\" in item) {\n          const { sync_action } = item;\n          if (sync_action !== undefined) {\n            if (!acc[sync_action]) {\n              acc[sync_action] = [];\n            }\n            acc[sync_action].push(item);\n          }\n        }\n        return acc;\n      },\n      {} as SyncedDBRequest<T>,\n    );\n\n    const url = new URL(this.options.url + this.options.syncPath);\n    url.searchParams.set(\"t\", timestamp.toString());\n\n    let response: Response;\n    if (this.options.dryRun) {\n      // handle deletions\n      let deleted: string[] = [];\n      if (\"delete\" in groups) {\n        deleted = groups.delete.map((item: T) => item[key]);\n      }\n\n      // handle updates\n      let updated: T[] = [];\n      if (\"update\" in groups) {\n        updated = JSON.parse(JSON.stringify(groups.update));\n      }\n\n      // handle creations\n      let created: T[] = [];\n      if (\"create\" in groups) {\n        created = JSON.parse(JSON.stringify(groups.create)).map((item: T) => {\n          item[key] = dryRunId(3);\n          return item;\n        });\n      }\n\n      console.log(`DRY RUN: POST ${url}`);\n      response = new Response(\n        JSON.stringify({\n          deleted,\n          changed: [...updated, ...created],\n          timestamp: Date.now(),\n        } as SyncedDBResponse<T>),\n        {\n          status: 200,\n          headers: { \"Content-Type\": \"application/json\" },\n        },\n      );\n    } else {\n      response = await fetch(url, {\n        method: \"POST\",\n        headers: { \"Content-Type\": \"application/json\" },\n        body: JSON.stringify(groups),\n        mode: \"cors\",\n        credentials: \"include\",\n      });\n    }\n\n    if (response.ok) {\n      const json = await response.json() as SyncedDBResponse<T>;\n      const store = this.#getStore(\"readwrite\");\n      const items = json.changed.map((item) =>\n        this.#addSyncState(item, \"none\", \"synced\")\n      );\n\n      await Promise.all([\n        // delete all items that are flagged as created on the client\n        idbx.delBulk(store, createTmpIds),\n        // delete all items that are flagged as deleted from the server\n        idbx.delBulk(store, json.deleted),\n        // update all items where sync_state is unsynced\n        idbx.putBulk(store, items),\n      ]);\n\n      this.dispatchEvent(new MessageEvent(\"synced\", { data: json }));\n      this.lastSync = new Date(json.timestamp).getTime();\n    } else {\n      // handle error\n      console.log(\"sync failed\", response);\n    }\n  }\n\n  #addSyncState(\n    data: T | undefined,\n    sync_action: SyncedDBAction,\n    sync_state: SyncedDBState,\n  ) {\n    return { ...data, sync_action, sync_state } as T;\n  }\n\n  #getStore(mode: IDBTransactionMode) {\n    const tx = this.db.transaction(this.storeName, mode);\n    return tx.objectStore(this.storeName);\n  }\n\n  #buildUrl(path: string, key: string | null = null) {\n    const url = new URL(this.options.url + path);\n    if (key) {\n      url.searchParams.set(this.options.keyName as string, key);\n    }\n    return url;\n  }\n\n  #fetchOne = async (\n    method: string,\n    path: string,\n    data: T | undefined,\n    key: string | null = null,\n  ) => {\n    const canHaveBody = method !== \"GET\" && method !== \"DELETE\";\n    const body = !canHaveBody ? undefined : JSON.stringify(data);\n    const url = this.#buildUrl(path, key);\n\n    let response: Response;\n    if (this.options.dryRun) {\n      const request = JSON.parse(body as string) as T;\n      let status = 200;\n      if (\"POST\" === method) {\n        const id = dryRunId(3);\n        request[this.options.keyName as string] = id;\n        status = 201;\n      } else if (\"DELETE\" === method) {\n        status = 204;\n      } else if (\"PUT\" === method) {\n        status = 200;\n      }\n\n      console.log(`DRY RUN: ${method} ${url}`);\n      response = new Response(JSON.stringify(request), {\n        status,\n        headers: { \"Content-Type\": \"application/json\" },\n      });\n    } else {\n      response = await fetch(url, {\n        method,\n        body,\n        mode: \"cors\",\n        credentials: \"include\",\n      });\n    }\n\n    if (response.ok) {\n      const store = this.#getStore(\"readwrite\");\n      if (method === \"DELETE\" && key) {\n        await idbx.del(store, key);\n        return;\n      } else {\n        const json = await response.json();\n        const item = this.#addSyncState(json, \"none\", \"synced\");\n        await idbx.put(store, item);\n        return item as T;\n      }\n    } else if (response.status === 404) {\n      if (key) {\n        const store = this.#getStore(\"readwrite\");\n        await idbx.del(store, key);\n      }\n    } else {\n      // handle error\n      console.log(\"read/write/delete entry failed\", response);\n    }\n  };\n}\n"],
  "mappings": "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",
  "names": ["idbx", "currentTime", "currentCount", "dryRunId", "padding", "now", "SyncedDB", "db", "storeName", "options", "resolve", "store", "data", "#getStore", "item", "#addSyncState", "key", "path", "result", "#fetchOne", "forceSync", "read", "record", "url", "response", "json", "items", "tmpItems", "timestamp", "syncStore", "unsynced", "createTmpIds", "groups", "acc", "sync_action", "deleted", "updated", "created", "sync_state", "mode", "#buildUrl", "method", "body", "request", "status", "id"]
}
